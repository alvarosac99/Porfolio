---
---

<canvas id="particle-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none;"></canvas>

<script>
    const canvas = document.getElementById('particle-canvas') as HTMLCanvasElement;
    const ctx = canvas.getContext('2d')!;

    // ── Config ──
    const PARTICLE_COUNT = 80;
    const CONNECTION_RADIUS = 120;
    const ATTRACTION_RADIUS = 180;
    const IDLE_SPEED = 0.3;
    const GRAVITY_FORCE = 0.05;
    const BURST_FORCE = 8;
    const BURST_DECAY = 0.95;
    const LINE_OPACITY = 0.4;
    const MIN_SIZE = 2;
    const MAX_SIZE = 10;
    const COLOR_IDLE = [107, 95, 101];     // #6B5F65
    const COLOR_ACTIVE = [255, 122, 66];   // #FF7A42
    const COLOR_LINES = [232, 97, 42];     // #E8612A

    // ── Simple Perlin noise ──
    const perm: number[] = [];
    for (let i = 0; i < 256; i++) perm[i] = i;
    for (let i = 255; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
    }
    for (let i = 0; i < 256; i++) perm[256 + i] = perm[i];

    function fade(t: number) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function lerp(a: number, b: number, t: number) { return a + t * (b - a); }
    function grad(hash: number, x: number, y: number) {
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
    }
    function noise2D(x: number, y: number) {
        const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
        const xf = x - Math.floor(x), yf = y - Math.floor(y);
        const u = fade(xf), v = fade(yf);
        return lerp(
            lerp(grad(perm[perm[X] + Y], xf, yf), grad(perm[perm[X + 1] + Y], xf - 1, yf), u),
            lerp(grad(perm[perm[X] + Y + 1], xf, yf - 1), grad(perm[perm[X + 1] + Y + 1], xf - 1, yf - 1), u),
            v
        );
    }

    // ── State ──
    let mouseX = -9999, mouseY = -9999;
    let time = 0;
    let W = 0, H = 0;

    // Hold mechanic
    let isHolding = false;
    let holdStartTime = 0;
    let holdDuration = 0;
    const HOLD_MAX_DURATION = 5000; // Increased to allow time for collection after 3s
    const COLLECTION_DELAY = 3000; // Start collecting after 3s
    const HOLD_ATTRACTION_FORCE = 1.2;
    const HOLD_BURST_FORCE = 30;
    const HOLD_MIN_RADIUS = 15;
    const COLLECT_RADIUS = 40; // particles within this radius get collected

    // Vortex state
    let vortexAngle = 0;
    let vortexSize = 0; // current visual radius

    interface Particle {
        x: number; y: number;
        vx: number; vy: number;
        size: number;
        noiseX: number; noiseY: number;
        baseAlpha: number;
        burstVx: number; burstVy: number;
        angle: number;
        collected: boolean;
    }

    let particles: Particle[] = [];

    // ── Setup ──
    function resize() {
        const dpr = window.devicePixelRatio || 1;
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function createParticles() {
        particles = [];
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particles.push({
                x: Math.random() * W,
                y: Math.random() * H,
                vx: 0, vy: 0,
                size: MIN_SIZE + Math.random() * (MAX_SIZE - MIN_SIZE),
                noiseX: Math.random() * 1000,
                noiseY: Math.random() * 1000,
                baseAlpha: 0.3 + Math.random() * 0.5,
                burstVx: 0, burstVy: 0,
                angle: (i / PARTICLE_COUNT) * Math.PI * 2,
                collected: false,
            });
        }
    }

    // ── Events ──
    window.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });

    document.addEventListener('mouseleave', () => {
        mouseX = -9999;
        mouseY = -9999;
    });

    window.addEventListener('mousedown', (e) => {
        isHolding = true;
        holdStartTime = performance.now();
        holdDuration = 0;
    });

    window.addEventListener('mouseup', (e) => {
        if (isHolding) {
            const elapsed = performance.now() - holdStartTime;
            isHolding = false;

            if (elapsed < 200) {
                // Short click → normal burst
                for (const p of particles) {
                    const dx = p.x - e.clientX;
                    const dy = p.y - e.clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < ATTRACTION_RADIUS * 1.5 && dist > 1) {
                        const force = BURST_FORCE * (1 - dist / (ATTRACTION_RADIUS * 1.5));
                        p.burstVx = (dx / dist) * force;
                        p.burstVy = (dy / dist) * force;
                    }
                }
            } else {
                // Long hold release → collected particles reappear at cursor and explode
                const power = Math.min(elapsed / HOLD_MAX_DURATION, 1);
                const burstRadius = 300 * (1 + power);
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    if (p.collected) {
                        // Reappear at cursor position (distributed slightly to avoid single-pixel clump)
                        p.x = e.clientX + (Math.random() - 0.5) * 40;
                        p.y = e.clientY + (Math.random() - 0.5) * 40;
                        p.collected = false;
                        // Strong burst outward - fully random angle for chaos
                        const burstAngle = Math.random() * Math.PI * 2;
                        const force = HOLD_BURST_FORCE * power * (0.5 + Math.random() * 0.8);
                        p.burstVx = Math.cos(burstAngle) * force;
                        p.burstVy = Math.sin(burstAngle) * force;
                    } else {
                        // Non-collected nearby particles get a softer push
                        const dx = p.x - e.clientX;
                        const dy = p.y - e.clientY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < burstRadius && dist > 1) {
                            const distFactor = 1 - dist / burstRadius;
                            const burstAngle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.4;
                            const force = HOLD_BURST_FORCE * power * distFactor * 0.5;
                            p.burstVx = Math.cos(burstAngle) * force;
                            p.burstVy = Math.sin(burstAngle) * force;
                        }
                    }
                }
            }
            holdDuration = 0;
        }
    });

    window.addEventListener('resize', () => {
        resize();
    });

    // ── Draw vortex spiral ──
    function drawVortex(cx: number, cy: number, radius: number, power: number) {
        const arms = 2;
        const maxTurns = 2;

        for (let arm = 0; arm < arms; arm++) {
            const armOffset = (arm / arms) * Math.PI * 2;
            ctx.beginPath();

            for (let i = 0; i <= 60; i++) {
                const t = i / 60;
                const angle = vortexAngle + armOffset + t * maxTurns * Math.PI * 2;
                const r = radius * t;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }

            const opacity = power * 0.1;
            ctx.strokeStyle = `rgba(${COLOR_ACTIVE[0]},${COLOR_ACTIVE[1]},${COLOR_ACTIVE[2]},${opacity})`;
            ctx.lineWidth = 0.8;
            ctx.stroke();
        }
    }

    // ── Animation ──
    function animate() {
        ctx.clearRect(0, 0, W, H);
        time += 0.004;

        // Count engulfed particles (low opacity near cursor)
        let engulfedCount = 0;
        let holdPower = 0;
        let exponentialPower = 0;
        let orbitRadius = 200;

        if (isHolding) {
            const currentHoldTime = performance.now() - holdStartTime;
            holdDuration = Math.min(currentHoldTime, HOLD_MAX_DURATION);
            
            // Ramp up power over first 3 seconds (collection delay)
            holdPower = Math.min(currentHoldTime / COLLECTION_DELAY, 1);
            exponentialPower = holdPower * holdPower * holdPower;
            orbitRadius = 200 * (1 - exponentialPower) + HOLD_MIN_RADIUS;

            // Count collected particles
            for (const p of particles) {
                if (p.collected) engulfedCount++;
            }

            // Vortex grows based on engulfed particles and hold power
            const engulfedRatio = engulfedCount / PARTICLE_COUNT; // 0→1
            // Slower spin (closer to original)
            vortexAngle += 0.04 + engulfedRatio * 0.12 + holdPower * 0.08;
            const targetSize = 20 + engulfedRatio * 130 + holdPower * 20;
            vortexSize = lerp(vortexSize, targetSize, 0.08);
        } else {
            vortexSize *= 0.9;
        }

        if (vortexSize > 1 && mouseX > 0) {
            const vortexPower = isHolding ? engulfedCount / PARTICLE_COUNT : vortexSize / 50;
            drawVortex(mouseX, mouseY, vortexSize, Math.min(vortexPower, 1));
        }

        // Update & draw particles
        for (const p of particles) {
            // Skip collected particles (they are in the vortex)
            if (p.collected) continue;

            // Perlin noise brownian motion
            p.vx = noise2D(p.noiseX + time, p.noiseY) * IDLE_SPEED;
            p.vy = noise2D(p.noiseY + time, p.noiseX) * IDLE_SPEED;

            // Burst decay
            if (Math.abs(p.burstVx) > 0.01 || Math.abs(p.burstVy) > 0.01) {
                p.vx += p.burstVx;
                p.vy += p.burstVy;
                p.burstVx *= BURST_DECAY;
                p.burstVy *= BURST_DECAY;
            }

            // Cursor attraction
            const dx = mouseX - p.x;
            const dy = mouseY - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            let colorT = 0;

            if (isHolding) {
                if (dist > 1) {
                    // Collect particle if close enough AND we have held for > 3 seconds
                    if (dist < COLLECT_RADIUS && (performance.now() - holdStartTime) > COLLECTION_DELAY) {
                        p.collected = true;
                        continue;
                    }

                    const gravityMultiplier = 1 / (1 + (dist * dist) / 5000);
                    const mass = 1 + (engulfedCount / PARTICLE_COUNT) * 3;

                    // Tangential spin — keep them moving!
                    const tangentX = -dy / dist;
                    const tangentY = dx / dist;
                    const spinStrength = exponentialPower * (0.2 + 0.5 * gravityMultiplier) * mass; // increased base speed
                    p.vx += tangentX * spinStrength;
                    p.vy += tangentY * spinStrength;

                    // Radial attraction
                    const radialForce = HOLD_ATTRACTION_FORCE * exponentialPower * (0.3 + 3.0 * gravityMultiplier) * mass;
                    p.vx += (dx / dist) * radialForce;
                    p.vy += (dy / dist) * radialForce;

                    // Damping: reduced friction near center so they don't stop
                    const damping = 0.96; // constant high damping to keep energy
                    p.vx *= damping;
                    p.vy *= damping;
                }
                colorT = Math.min(1, exponentialPower * 1.5);

                // Fade opacity as approaching collection
                if (dist < COLLECT_RADIUS * 3) {
                    const proximityT = 1 - dist / (COLLECT_RADIUS * 3);
                    colorT = Math.max(colorT, proximityT);
                }
            } else if (dist < ATTRACTION_RADIUS && dist > 1) {
                const force = GRAVITY_FORCE * (1 - dist / ATTRACTION_RADIUS);
                p.vx += (dx / dist) * force;
                p.vy += (dy / dist) * force;
                colorT = 1 - dist / ATTRACTION_RADIUS;
            }

            // Apply velocity
            p.x += p.vx;
            p.y += p.vy;

            // Bounce
            if (p.x < 0) { p.x = 0; p.vx *= -0.5; }
            if (p.x > W) { p.x = W; p.vx *= -0.5; }
            if (p.y < 0) { p.y = 0; p.vy *= -0.5; }
            if (p.y > H) { p.y = H; p.vy *= -0.5; }

            // Color interpolation
            const r = Math.round(COLOR_IDLE[0] + (COLOR_ACTIVE[0] - COLOR_IDLE[0]) * colorT);
            const g = Math.round(COLOR_IDLE[1] + (COLOR_ACTIVE[1] - COLOR_IDLE[1]) * colorT);
            const b = Math.round(COLOR_IDLE[2] + (COLOR_ACTIVE[2] - COLOR_IDLE[2]) * colorT);
            const alpha = p.baseAlpha + (1 - p.baseAlpha) * colorT;

            // Draw particle or trail if moving fast
            ctx.beginPath();
            const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            if (speed > 2) {
                // High speed → draw distinct trail
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x - p.vx * 2, p.y - p.vy * 2);
                ctx.lineWidth = p.size / 2;
                ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
                ctx.lineCap = 'round';
                ctx.stroke();
            } else {
                // Low speed → draw circle
                ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                ctx.fill();
            }
        }

        // Draw orbit dots for collected particles
        if (engulfedCount > 0 && mouseX > 0) {
            const orbitDots = Math.min(Math.ceil(engulfedCount / 4), 15);
            const orbitR = 18 + engulfedCount * 0.3 + holdPower * 10;
            
            // Removed white flash logic - keep original color
            let dotR = COLOR_ACTIVE[0];
            let dotG = COLOR_ACTIVE[1];
            let dotB = COLOR_ACTIVE[2];

            for (let i = 0; i < orbitDots; i++) {
                const a = vortexAngle * 2 + (i / orbitDots) * Math.PI * 2;
                const ox = mouseX + Math.cos(a) * orbitR;
                const oy = mouseY + Math.sin(a) * orbitR;
                const dotSize = 3 + Math.sin(time * 30 + i) * 1 + holdPower * 2;
                const dotAlpha = 0.8 + 0.2 * Math.sin(time * 40 + i);
                ctx.beginPath();
                ctx.arc(ox, oy, dotSize, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${dotR},${dotG},${dotB},${dotAlpha})`;
                ctx.fill();
            }
        }



        requestAnimationFrame(animate);
    }

    // ── Init ──
    resize();
    createParticles();
    requestAnimationFrame(animate);
</script>
